<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, maximum-scale=1.0, user-scalable=no">
  <title>Chat with TumzyTech</title>  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="assets/css/styles.css">
  <link rel="icon" href="assets/pictures/favicon.ico" type="image/x-icon">  <script src="assets/js/page-loader.js"></script>
  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  <link rel="preconnect" href="https://sdk.minepi.com">
  <link rel="preconnect" href="https://api.openrouter.ai">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.9.6/lottie.min.js" defer></script>
  <script src="https://sdk.minepi.com/pi-sdk.js"></script>
  <script src="assets/js/pi-payments.js" defer></script>
  <script src="assets/js/api-test.js" defer></script>
  <style>
    /* Placeholder background for faster initial load */
    body {
      background: url('assets/pictures/robot-placeholder.png') center/cover no-repeat;
      background-color: #4c1d95; /* Fallback color */
    }    #video-background {
      position: fixed;
      right: 0;
      bottom: 0;
      min-width: 100%;
      min-height: 100%;
      width: auto;
      height: auto;
      z-index: -2;
    }

    /* Add a dynamic purple gradient background */
    body {
      background: linear-gradient(270deg, #7e22ce, #4c1d95, #9333ea, #7e22ce);
      background-size: 400% 400%;
      animation: dynamicPurple 10s ease infinite;
      color: #ffffff; /* Ensure text is bright and readable */
      font-family: 'Inter', sans-serif;
    }

    @keyframes dynamicPurple {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Remove tech-style animation background if file is missing */
    #tech-animation {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
      opacity: 0.2;
    }

    /* Add a container for the AI tech icons animation */
    #ai-tech-animation {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
    }

    /* Add a container for the video background */
    #video-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      overflow: hidden;
    }

    #video-background video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Facebook Messenger-like styling */
    .chat-container {
      background: rgba(24, 26, 39, 0.9);
      border-radius: 15px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      padding: 20px;
      max-width: 600px;
      margin: 50px auto;
      border: none;
      animation: fadeInUp 1.5s ease-in-out;
      margin-top: 100px; /* Push the chat box lower to avoid overlapping with the back button */
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(50px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .chat-header {
      font-size: 1.5rem;
      font-weight: bold;
      text-align: center;
      margin-bottom: 20px;
      background: linear-gradient(90deg, #9333ea, #2563eb);
      padding: 10px;
      border-radius: 10px;
      color: #ffffff;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }

    .chat-window {
      height: 300px;
      overflow-y: auto;
      padding: 10px;
      background: rgba(37, 99, 235, 0.1);
      border-radius: 10px;
      margin-bottom: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .chat-message {
      max-width: 70%;
      padding: 10px;
      border-radius: 15px;
      word-wrap: break-word;
      display: inline-block;
    }

    .chat-message.bot {
      background: linear-gradient(90deg, #9333ea, #2563eb);
      color: #ffffff;
      align-self: flex-start;
    }

    .chat-message.user {
      background: linear-gradient(90deg, #2563eb, #9333ea);
      color: #ffffff;
      align-self: flex-end;
    }

    .chat-input {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .chat-input input {
      flex: 1;
      padding: 10px;
      border-radius: 20px;
      border: none;
      outline: none;
      background: rgba(24, 26, 39, 0.9);
      color: #ffffff;
      font-size: 1rem;
    }

    .chat-input button {
      padding: 10px 20px;
      border-radius: 20px;
      border: none;
      background: linear-gradient(90deg, #9333ea, #2563eb);
      color: #ffffff;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .chat-input button:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(124, 58, 237, 0.8);
    }

    /* Ensure sharp graphics on mobile */
    img, video {
      image-rendering: auto;
      -webkit-optimize-contrast: high;
    }

    /* Adjust spacing for chatbox */
    .chatbox {
      margin-top: 20px; /* Add spacing between 'Back to Homepage' and chatbox */
    }

    @media (max-width: 768px) {
      .back-button {
        position: absolute;
        top: 10px;
        left: 10px;
        margin-bottom: 0; /* Remove extra spacing */
      }

      .chat-header {
        margin-top: 50px; /* Add spacing to align with the back button */
      }
    }
  </style>
</head>
<body>  <a href="index.html" class="absolute top-4 left-4 px-6 py-3 text-purple-500 rounded-lg shadow hover:text-purple-400 transition font-semibold text-lg glow-logo back-button">Back</a>
  <div id="video-background">
    <video autoplay muted loop playsinline>
      <source src="assets/videos/background-video.mp4" type="video/mp4">
      Your browser does not support the video tag.
    </video>
  </div>
  <canvas id="particles-bg" class="fixed top-0 left-0 w-full h-full z-0 pointer-events-none"></canvas>
  <div id="tech-animation"></div>
  <div id="ai-tech-animation"></div>  <div class="chat-container">
    <div class="chat-header">Chat with TumzyBot</div>
    <div id="pi-sandbox-status" class="text-center mb-1 text-xs text-yellow-300"></div>
    <div id="server-connection-status" class="text-center mb-1 text-xs"></div>
    <div id="api-status" class="text-center mb-1 text-xs text-gray-400">OpenRouter API: Unknown</div>
    <div id="subscription-status" class="text-center mb-2 text-sm text-gray-300"></div>
    <div id="chat-window" class="chat-window">
      <div class="chat-message bot">Hello! How can I assist you with TumzyTech today?</div>
    </div>
    <form id="chat-form" class="chat-input">
      <input type="text" id="user-input" placeholder="Type your message...">
      <button type="submit">Send</button>
    </form>    <div class="flex justify-between mt-2">
      <button id="pay-button" class="px-4 py-2 bg-blue-500 text-white rounded">Subscribe with Pi</button>
      <div id="trial-counter" class="text-sm text-gray-300 self-center"></div>
    </div>
    <div class="flex justify-center mt-2">
      <button id="test-api-button" class="px-3 py-1 bg-purple-700 text-white rounded text-xs">Test OpenRouter Connection</button>
    </div>    <div id="pi-help" class="mt-3 text-xs text-gray-300 hidden">
      <p class="font-bold text-yellow-300">Pi Browser Settings:</p>
      <ol class="list-decimal pl-5">
        <li>Open Pi Browser settings (tap the menu icon)</li>
        <li>Scroll down to "Developer Options"</li>
        <li>Enable "Sandbox Mode" for testing</li>
        <li>Restart the Pi Browser app</li>
      </ol>
    </div>
    <div id="api-help" class="mt-3 text-xs text-gray-300 hidden">
      <p class="font-bold text-yellow-300">OpenRouter API Troubleshooting:</p>
      <ol class="list-decimal pl-5">
        <li>Check your internet connection</li>
        <li>Your network might be blocking api.openrouter.ai</li>
        <li>Try changing your DNS settings to Google DNS (8.8.8.8)</li>
        <li>Check if OpenRouter is experiencing service issues</li>
      </ol>
      <a href="https://openrouter.ai/status" target="_blank" class="text-blue-400 underline block mt-1 text-center">Check OpenRouter Status</a>
    </div>
  </div>  <script>

    const chatWindow = document.getElementById('chat-window');
    const chatForm = document.getElementById('chat-form');
    const userInput = document.getElementById('user-input');

    // Ensure tailored greetings are displayed correctly
    const serviceGreetings = {
      'AI-Driven Content Creation': 'Hello! Ready to create amazing content with AI? Let me guide you.',
      'AI-Generated Graphics & Animation': 'Hi there! Let’s design stunning visuals and animations together.',
      'AI Market Analysis & Financial Mgmt.': 'Welcome! Let’s dive into market trends and financial insights.',
      'AI-Powered Financial Assistant': 'Hello! I’m here to assist with your financial planning and automation.',
      'default': 'Hello! How can I assist you with TumzyTech today?'
    };

    const urlParams = new URLSearchParams(window.location.search);
    const serviceName = urlParams.get('service');

    if (serviceName && serviceGreetings[serviceName]) {
      const botMessageDiv = document.createElement('div');
      botMessageDiv.className = 'chat-message bot';
      botMessageDiv.textContent = serviceGreetings[serviceName];
      chatWindow.appendChild(botMessageDiv);
    }

    // Update subscription and trial status in UI
    function updateSubscriptionUI(data) {
      const subscriptionStatus = document.getElementById('subscription-status');
      const trialCounter = document.getElementById('trial-counter');
      
      if (data.subscriptionActive) {
        // User has active subscription
        const endDate = new Date(data.subscriptionEndDate);
        subscriptionStatus.textContent = `Premium subscription active until ${endDate.toLocaleDateString()}`;
        subscriptionStatus.classList.add('text-green-400');
        trialCounter.textContent = '';
      } else if (data.trialRemaining > 0) {
        // User has trial messages left
        subscriptionStatus.textContent = '';
        trialCounter.textContent = `${data.trialRemaining} free messages left`;
      } else {
        // No subscription and no trial messages
        subscriptionStatus.textContent = 'Free trial ended. Subscribe to continue.';
        subscriptionStatus.classList.add('text-yellow-400');
        trialCounter.textContent = '';
      }
    }
    
    chatForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const message = userInput.value.trim();
      if (message) {
        const userMessageDiv = document.createElement('div');
        userMessageDiv.className = 'chat-message user';
        userMessageDiv.textContent = message;
        chatWindow.appendChild(userMessageDiv);
        userInput.value = '';
        chatWindow.scrollTop = chatWindow.scrollHeight;
        
        // Show typing indicator
        const typingDiv = document.createElement('div');
        typingDiv.className = 'chat-message bot';
        typingDiv.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
        typingDiv.style.padding = '10px';
        chatWindow.appendChild(typingDiv);
        chatWindow.scrollTop = chatWindow.scrollHeight;        try {
          // Determine API endpoint based on environment
          let apiUrl = 'http://localhost:5000/api/services/chatbot';
          
          // Check if running in Pi Browser or on a different port
          if (isRunningInPiBrowser() || window.location.port !== '5000') {
            // Try multiple possible endpoints
            const endpoints = [
              window.location.origin + '/api/services/chatbot',
              'http://localhost:5000/api/services/chatbot',
              'http://127.0.0.1:5000/api/services/chatbot'
            ];
            
            // Use the first endpoint by default (current origin)
            apiUrl = endpoints[0];
            console.log('Using dynamic URL:', apiUrl);
            
            // Add server status indicator
            const statusDiv = document.createElement('div');
            statusDiv.className = 'text-xs text-center mb-2';
            statusDiv.textContent = 'Connecting to server...';
            statusDiv.id = 'server-status';
            if (!document.getElementById('server-status')) {
              chatWindow.appendChild(statusDiv);
            }
          }
          
          // Try to connect to the server with multiple endpoints
          let response;
          let serverConnected = false;
          let serverStatusElement = document.getElementById('server-status');
          const serverConnectionStatus = document.getElementById('server-connection-status');
          
          // Update server connection status display
          if (serverConnectionStatus) {
            serverConnectionStatus.textContent = 'Connecting to server...';
            serverConnectionStatus.className = 'text-center mb-1 text-xs text-yellow-300';
          }
          
          // List of endpoints to try - ONLY use the backend server, not the current origin
          // This is because the current origin is likely a file:// or http://127.0.0.1:5500 from live server
          // which doesn't have the backend API
          const endpoints = [
            'http://localhost:5000/api/services/chatbot',
            'http://127.0.0.1:5000/api/services/chatbot'
          ];
          
          // Try each endpoint
          for (const endpoint of endpoints) {
            try {
              console.log(`Trying endpoint: ${endpoint}`);
              if (serverStatusElement) {
                serverStatusElement.textContent = `Trying to connect to ${endpoint}...`;
              }
              
              // Use a shorter timeout to avoid long waits
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 3000);
              
              // Special handling for Pi Browser to avoid CORS issues
              if (isRunningInPiBrowser()) {
                // In Pi Browser, we need to be more careful with CORS
                response = await fetch(endpoint, {
                  method: 'POST',
                  headers: { 
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                  },
                  mode: 'cors', // Try with explicit CORS mode
                  credentials: 'omit', // Don't send cookies to avoid CORS preflight
                  body: JSON.stringify({ 
                    message,
                    isPiBrowser: true, // Let the server know this is from Pi Browser
                    timestamp: Date.now() // Add timestamp to prevent caching
                  }),
                  signal: controller.signal
                });
              } else {
                // Regular fetch for non-Pi Browser
                response = await fetch(endpoint, {
                  method: 'POST',
                  headers: { 
                    'Content-Type': 'application/json'
                  },
                  credentials: 'include',
                  body: JSON.stringify({ message }),
                  signal: controller.signal
                });
              }
              
              // Clear the timeout
              clearTimeout(timeoutId);
              
              // Check if response is valid
              if (response.ok) {
                serverConnected = true;
                console.log(`Connected to ${endpoint}`);
                
                if (serverStatusElement) {
                  serverStatusElement.textContent = `Connected to server`;
                  serverStatusElement.classList.add('text-green-400');
                  // Remove after 2 seconds
                  setTimeout(() => {
                    if (serverStatusElement && serverStatusElement.parentNode) {
                      serverStatusElement.parentNode.removeChild(serverStatusElement);
                    }
                  }, 2000);
                }
                
                if (serverConnectionStatus) {
                  serverConnectionStatus.textContent = 'Server connected';
                  serverConnectionStatus.className = 'text-center mb-1 text-xs text-green-400';
                }
                
                break;
              } else {
                console.log(`Server returned error status: ${response.status}`);
                throw new Error(`Server returned status: ${response.status}`);
              }
            } catch (endpointError) {
              console.log(`Failed to connect to ${endpoint}:`, endpointError);
              // Continue to next endpoint
            }
          }
          
          // If all endpoints failed, use a local fallback response
          if (!serverConnected) {
            console.log('All server endpoints failed, using local fallback');
            
            // Create a fallback response
            const fallbackResponses = {
              'hello': 'Hello! I\'m currently in offline mode due to server connectivity issues. Basic responses are available.',
              'hi': 'Hi there! The server is currently unavailable. I can provide limited responses in offline mode.',
              'help': 'I\'m in offline mode due to server connectivity issues. Please check your server connection or try again later.',
              'default': 'I apologize, but I\'m currently in offline mode due to server connectivity issues. Please check that your server is running at http://localhost:5000 or try again later.'
            };
            
            // Get a simple response based on the message
            const lowerMessage = message.toLowerCase().trim();
            let responseText = fallbackResponses.default;
            
            // Check for simple keywords
            for (const [key, value] of Object.entries(fallbackResponses)) {
              if (lowerMessage.includes(key)) {
                responseText = value;
                break;
              }
            }
            
            // Add server status information
            if (serverStatusElement) {
              serverStatusElement.textContent = 'Server unavailable - using offline mode';
              serverStatusElement.classList.add('text-yellow-400');
            }
            
            // Create a mock response object
            response = {
              status: 200,
              json: async () => ({ 
                response: responseText + ' (OFFLINE MODE)',
                offline: true
              })
            };
          }
          
          // Safely remove typing indicator
          if (typingDiv && typingDiv.parentNode === chatWindow) {
            chatWindow.removeChild(typingDiv);
          }
          
          if (response.status === 402) {
            // Payment required
            const data = await response.json();
            const botMessageDiv = document.createElement('div');
            botMessageDiv.className = 'chat-message bot';
            botMessageDiv.innerHTML = `${data.message} <button id="subscribe-now" class="bg-green-500 text-white px-2 py-1 rounded text-xs ml-2">Subscribe Now</button>`;
            chatWindow.appendChild(botMessageDiv);
            
            // Add event listener to the subscribe button
            document.getElementById('subscribe-now').addEventListener('click', () => {
              createPayment('chatSubscription');
            });
          } else {
            // Add better error handling for JSON parsing
            let data;
            try {
              data = await response.json();
            } catch (jsonError) {
              console.error('Error parsing JSON response:', jsonError);
              
              // Create a fallback response for JSON parsing errors
              data = {
                response: 'Sorry, there was an error processing the server response. This might be due to server maintenance or connectivity issues.',
                error: 'JSON_PARSE_ERROR'
              };
              
              // Update server status indicator
              const serverConnectionStatus = document.getElementById('server-connection-status');
              if (serverConnectionStatus) {
                serverConnectionStatus.textContent = 'Server response error';
                serverConnectionStatus.className = 'text-center mb-1 text-xs text-red-400';
              }
            }
            
            const botMessageDiv = document.createElement('div');
            botMessageDiv.className = 'chat-message bot';
            botMessageDiv.textContent = data.response;
            chatWindow.appendChild(botMessageDiv);
            
            // Update subscription and trial status if available
            if (data.trialRemaining !== undefined || data.subscriptionActive !== undefined) {
              updateSubscriptionUI(data);
            }
          }
          
          chatWindow.scrollTop = chatWindow.scrollHeight;        } catch (error) {
          console.error('Error communicating with chatbot API:', error);
          
          // Safely remove typing indicator
          if (typingDiv && typingDiv.parentNode === chatWindow) {
            chatWindow.removeChild(typingDiv);
          }
          
          // Check internet connectivity
          const isOnline = navigator.onLine;
          let errorMessage = 'Sorry, there was an error connecting to the chatbot.';
          
          // Check if running in Pi Browser
          const isPiBrowser = isRunningInPiBrowser();
          
          if (!isOnline) {
            errorMessage = 'You appear to be offline. Please check your internet connection and try again.';
          } else if (isPiBrowser) {
            errorMessage = 'Connection error in Pi Browser. Make sure you have enabled sandbox mode in Pi Browser settings and have a stable internet connection.';          } else if (error.message && (error.message.includes('ENOTFOUND') || error.message.includes('api.openrouter.ai'))) {
            errorMessage = 'Unable to reach our AI service provider (OpenRouter). This could be due to network restrictions, DNS issues, or OpenRouter service disruption.';
          } else if (error.message && error.message.includes('Failed to fetch')) {
            errorMessage = 'Connection to server failed. Please make sure the server is running at http://localhost:5000.';
          } else if (error.message && error.message.includes('ETIMEDOUT')) {
            errorMessage = 'Connection to AI service timed out. This may be due to network issues or high traffic on the AI service.';
          } else if (error.message && error.message.includes('AUTHENTICATION_FAILED')) {
            errorMessage = 'Unable to authenticate with the AI service. This is a server configuration issue.';
          }
          
          // Show error message
          const errorDiv = document.createElement('div');
          errorDiv.className = 'chat-message bot';
          errorDiv.textContent = errorMessage;
          chatWindow.appendChild(errorDiv);
          
          // Add retry button
          const retryButton = document.createElement('button');
          retryButton.textContent = 'Retry Connection';
          retryButton.className = 'bg-blue-500 text-white px-3 py-1 rounded mt-2 mx-auto block';
          retryButton.addEventListener('click', async () => {
            try {
              // Determine which endpoint to test based on environment
              let healthEndpoint = 'http://localhost:5000/api/health';
              
              // If in Pi Browser, use the origin-based URL
              if (isRunningInPiBrowser()) {
                healthEndpoint = window.location.origin + '/api/health';
                console.log('Testing Pi Browser connection with:', healthEndpoint);
              }
              
          // Simple connectivity test with proper error handling
          // Use a controller to set a timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 3000);
          
          try {
            // Special handling for Pi Browser
            if (isRunningInPiBrowser()) {
              // For Pi Browser, use a more robust approach with multiple attempts
              let success = false;
              
              // Try different approaches
              try {
                // First try: Simple GET with no-cors
                const testResponse = await fetch(healthEndpoint, { 
                  method: 'GET',
                  mode: 'no-cors',
                  signal: AbortSignal.timeout(2000)
                });
                success = true;
              } catch (e) {
                console.log('First attempt failed:', e);
                
                try {
                  // Second try: Use XMLHttpRequest which might work better in Pi Browser
                  await new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', healthEndpoint);
                    xhr.timeout = 2000;
                    xhr.onload = () => resolve();
                    xhr.onerror = () => reject(new Error('XHR failed'));
                    xhr.ontimeout = () => reject(new Error('XHR timeout'));
                    xhr.send();
                  });
                  success = true;
                } catch (e2) {
                  console.log('Second attempt failed:', e2);
                  
                  // Third try: Use a fetch with different options
                  try {
                    const testResponse = await fetch(healthEndpoint.replace('http://', 'https://'), { 
                      method: 'GET',
                      mode: 'no-cors',
                      cache: 'no-cache',
                      signal: AbortSignal.timeout(2000)
                    });
                    success = true;
                  } catch (e3) {
                    console.log('Third attempt failed:', e3);
                    throw new Error('All connection attempts failed');
                  }
                }
              }
            } else {
              // For regular browsers, use the standard approach
              const testResponse = await fetch(healthEndpoint, { 
                method: 'GET',
                mode: 'no-cors',
                signal: controller.signal
              });
              
              // Clear the timeout
              clearTimeout(timeoutId);
              
              // Actually verify the server is running by trying to connect to the chatbot endpoint
              // This is a more reliable test than just checking if the health endpoint responds
              const chatbotEndpoint = healthEndpoint.replace('/api/health', '/api/services/chatbot');
              
              // Try a HEAD request first to avoid CORS issues with POST
              const chatbotTest = await fetch(chatbotEndpoint, {
                method: 'HEAD',
                mode: 'no-cors',
                signal: AbortSignal.timeout(3000)
              });
            }
            
            const refreshDiv = document.createElement('div');
            refreshDiv.className = 'chat-message bot';
            
            if (isRunningInPiBrowser()) {
              refreshDiv.innerHTML = 'Connection test completed. <strong>If you are using Pi Browser, make sure Sandbox Mode is enabled in Pi Browser settings.</strong>';
            } else {
              refreshDiv.textContent = 'Connection restored! You can now continue chatting.';
            }
            
            // Update the server status indicator
            const serverConnectionStatus = document.getElementById('server-connection-status');
            if (serverConnectionStatus) {
              serverConnectionStatus.textContent = 'Server online';
              serverConnectionStatus.className = 'text-center mb-1 text-xs text-green-400';
            }
          } catch (error) {
            // If there's an error, the server is still not available
            throw new Error('Server still not available');
          }
              
              chatWindow.appendChild(refreshDiv);
              chatWindow.scrollTop = chatWindow.scrollHeight;
              
            } catch (e) {
              const refreshDiv = document.createElement('div');
              refreshDiv.className = 'chat-message bot';
              
              if (isRunningInPiBrowser()) {
                refreshDiv.innerHTML = 'Still unable to connect. For Pi Browser: <ol class="list-decimal pl-5 mt-2"><li>Check that you have enabled Sandbox Mode in Pi Browser settings</li><li>Make sure you have a stable internet connection</li><li>Try closing and reopening the Pi Browser app</li></ol>';
              } else {
                refreshDiv.textContent = 'Still unable to connect. Please check your network connection and make sure the server is running.';
              }
              
              chatWindow.appendChild(refreshDiv);
              chatWindow.scrollTop = chatWindow.scrollHeight;
            }
          });
          
          chatWindow.appendChild(retryButton);
          chatWindow.scrollTop = chatWindow.scrollHeight;
        }
      }
    });
    
    // Add typing indicator styles
    const style = document.createElement('style');
    style.textContent = `
      .typing-indicator {
        display: flex;
        align-items: center;
      }
      .typing-indicator span {
        height: 8px;
        width: 8px;
        background: #fff;
        border-radius: 50%;
        display: inline-block;
        margin: 0 2px;
        animation: typing 1.5s infinite ease-in-out;
      }
      .typing-indicator span:nth-child(2) {
        animation-delay: 0.2s;
      }
      .typing-indicator span:nth-child(3) {
        animation-delay: 0.4s;
      }
      @keyframes typing {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-10px); }
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>
